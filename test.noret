const int8:constant=42;
typedef int int32;
const int[]:y={1234567890123456789,2,3.0};
const any: array_test =(int32[][]:){{1,2,3},{4,5},{6}};
const string8[]:str_test={"str1","str2"};
const int32[][]?[]:type_sig_test={};
struct struct_test{int32:a,int32:b};
const struct_test:aStruct={.a=0,.b=1};
## struct struct_test{tuple{int32,int64}:a,union{int32:c,float64:d}:b};

start(string8[]):(args)=>{
    assert "args.length<3" : args.length<3;
    log.debug args;
    log.debug "args[0]=";
    _log.debug args.length>0?args[0]:"No Arguments Provided";
    ##struct_test:aStruct={.a={0,1},.b=0};
    ## log aStruct;
    log aStruct.type;
    string8:utf8=u8"UTF8-String:aÂ°ðŸ’»";
    string16:utf16=u16"UTF16-String:aÂ°ðŸ’»";
    string32:utf32=u32"UTF32-String:aÂ°ðŸ’»";
    log utf8;
    log utf8.length;
    log 'a';
    log utf16;
    log utf16.length;
    log 'Â°';
    log utf32;
    log utf32.length;
    log 'ðŸ’»';
    any:anAny=3;
    log anAny.type;
    tuple{int32,int32,int32}:aTuple={1,2,3};
    ## log aTuple;
    log aTuple.type;
    log aTuple.length;
    log start;
    log start.type;
    int:add=1+(int:)(args.length);
    int:mathTest=add*add-add//2;
    log mathTest;
    log y;
    log y[0];
    log y.type;
    log type_sig_test.type;
    uint64:y_len=y.length;
    log y_len;
    int32[]:x=(int32[]:){1,2,3,constant};
    x[0]=123456789;
    log x[0];
    log x;
    log none.type;
    log {}.type;
    int32?:optional=4;
    log optional;
    log optional?optional.value:none;
}=>[]
